const PDFDocument = require('pdfkit');
const { Document, Paragraph, TextRun, HeadingLevel } = require('docx');
const fs = require('fs');
const path = require('path');

class ExportService {
  /**
   * Export chat to PDF
   */
  async exportChatToPDF(chat, outputPath) {
    return new Promise((resolve, reject) => {
      try {
        const doc = new PDFDocument({
          size: 'A4',
          margins: {
            top: 50,
            bottom: 50,
            left: 50,
            right: 50
          }
        });

        const stream = fs.createWriteStream(outputPath);
        doc.pipe(stream);

        // Header
        doc.fontSize(24)
           .fillColor('#6054FF')
           .text('Wand AI Conversation', { align: 'center' });

        doc.moveDown();
        doc.fontSize(16)
           .fillColor('#666666')
           .text(chat.title, { align: 'center' });

        doc.moveDown();
        doc.fontSize(10)
           .fillColor('#999999')
           .text(`Created: ${new Date(chat.createdAt).toLocaleString()}`, { align: 'center' });

        doc.moveDown(2);

        // Draw separator line
        doc.strokeColor('#6054FF')
           .lineWidth(2)
           .moveTo(50, doc.y)
           .lineTo(550, doc.y)
           .stroke();

        doc.moveDown(1.5);

        // Messages
        chat.messages.forEach((message, index) => {
          // Check if we need a new page
          if (doc.y > 700) {
            doc.addPage();
          }

          if (message.isUser) {
            // User message
            doc.fontSize(12)
               .fillColor('#333333')
               .font('Helvetica-Bold')
               .text('You:', { continued: false });
            
            doc.fontSize(11)
               .fillColor('#000000')
               .font('Helvetica')
               .text(message.text, { 
                 align: 'left',
                 indent: 20
               });
          } else {
            // AI response
            doc.fontSize(12)
               .fillColor('#6054FF')
               .font('Helvetica-Bold')
               .text('Wand AI:', { continued: false });

            doc.fontSize(11)
               .fillColor('#000000')
               .font('Helvetica')
               .text(message.text, {
                 align: 'left',
                 indent: 20
               });

            // Agent information
            if (message.agents && message.agents.length > 0) {
              doc.fontSize(9)
                 .fillColor('#666666')
                 .font('Helvetica-Oblique')
                 .text(`Agents: ${message.agents.map(a => a.name).join(', ')}`, {
                   indent: 20
                 });
            }
          }

          doc.moveDown(1.5);
        });

        // Footer
        doc.fontSize(8)
           .fillColor('#999999')
           .text(
             `Generated by Wand AI - ${new Date().toLocaleString()}`,
             50,
             doc.page.height - 50,
             { align: 'center' }
           );

        doc.end();

        stream.on('finish', () => resolve(outputPath));
        stream.on('error', reject);
      } catch (error) {
        reject(error);
      }
    });
  }

  /**
   * Export chat to DOCX
   */
  async exportChatToDOCX(chat, outputPath) {
    try {
      const sections = [];

      // Title and metadata
      const headerParagraphs = [
        new Paragraph({
          text: 'Wand AI Conversation',
          heading: HeadingLevel.HEADING_1,
          alignment: 'center',
        }),
        new Paragraph({
          text: chat.title,
          heading: HeadingLevel.HEADING_2,
          alignment: 'center',
        }),
        new Paragraph({
          text: `Created: ${new Date(chat.createdAt).toLocaleString()}`,
          alignment: 'center',
          spacing: { after: 400 }
        })
      ];

      // Messages
      const messageParagraphs = [];
      chat.messages.forEach((message, index) => {
        if (message.isUser) {
          messageParagraphs.push(
            new Paragraph({
              children: [
                new TextRun({
                  text: 'You: ',
                  bold: true,
                  color: '333333'
                })
              ],
              spacing: { before: 200 }
            }),
            new Paragraph({
              text: message.text,
              indent: { left: 400 },
              spacing: { after: 200 }
            })
          );
        } else {
          messageParagraphs.push(
            new Paragraph({
              children: [
                new TextRun({
                  text: 'Wand AI: ',
                  bold: true,
                  color: '6054FF'
                })
              ],
              spacing: { before: 200 }
            }),
            new Paragraph({
              text: message.text,
              indent: { left: 400 }
            })
          );

          if (message.agents && message.agents.length > 0) {
            messageParagraphs.push(
              new Paragraph({
                children: [
                  new TextRun({
                    text: `Agents: ${message.agents.map(a => a.name).join(', ')}`,
                    italics: true,
                    size: 18,
                    color: '666666'
                  })
                ],
                indent: { left: 400 },
                spacing: { after: 200 }
              })
            );
          }
        }
      });

      // Footer
      const footerParagraphs = [
        new Paragraph({
          text: `Generated by Wand AI - ${new Date().toLocaleString()}`,
          alignment: 'center',
          spacing: { before: 400 }
        })
      ];

      const doc = new Document({
        sections: [{
          properties: {},
          children: [
            ...headerParagraphs,
            ...messageParagraphs,
            ...footerParagraphs
          ]
        }]
      });

      const buffer = await require('docx').Packer.toBuffer(doc);
      await fs.promises.writeFile(outputPath, buffer);
      
      return outputPath;
    } catch (error) {
      throw error;
    }
  }

  /**
   * Generate temporary file path for export
   */
  getTempExportPath(chatId, format) {
    const filename = `chat-${chatId}-${Date.now()}.${format}`;
    return path.join(__dirname, '../../exports', filename);
  }

  /**
   * Clean up old export files
   */
  async cleanupOldExports() {
    try {
      const exportsDir = path.join(__dirname, '../../exports');
      const files = await fs.promises.readdir(exportsDir);
      const now = Date.now();
      const maxAge = 60 * 60 * 1000; // 1 hour

      for (const file of files) {
        const filePath = path.join(exportsDir, file);
        const stats = await fs.promises.stat(filePath);
        
        if (now - stats.mtimeMs > maxAge) {
          await fs.promises.unlink(filePath);
        }
      }
    } catch (error) {
      console.error('Error cleaning up exports:', error);
    }
  }
}

module.exports = new ExportService();
